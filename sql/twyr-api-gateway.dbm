<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.8.1" last-position="1917,284" last-zoom="0.7"
	 default-schema="public" default-owner="postgres">
<database name="twyr-api-gateway">
</database>

<schema name="public" protected="true" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<usertype name="module_type" configuration="enumeration">
	<schema name="public"/>
	<role name="postgres"/>
	<enumeration values="component,middleware,service"/>
</usertype>

<extension name="uuid-ossp">
	<schema name="public"/>
</extension>

<function name="fn_assign_module_to_tenant"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF NEW.type <> 'component'
	THEN
		RETURN NEW;
	END IF;

	IF NEW.admin_only = true
	THEN
		INSERT INTO tenant_modules (
			tenant_id,
			module_id
		)
		SELECT 
			id,
			NEW.id
		FROM
			tenants
		WHERE
			parent_id IS NULL;
	END IF;

	IF NEW.admin_only = false
	THEN
		INSERT INTO tenant_modules (
			tenant_id,
			module_id
		)
		SELECT 
			id,
			NEW.id
		FROM
			tenants;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<function name="fn_get_module_ancestors"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="level">
		<type name="integer"/>
	</parameter>
	<parameter name="id">
		<type name="uuid"/>
	</parameter>
	<parameter name="parent_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="name">
		<type name="text"/>
	</parameter>
	<parameter name="type">
		<type name="public.module_type" precision="0"/>
	</parameter>
	</return-type>
	<parameter name="moduleid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
BEGIN
	RETURN QUERY
	WITH RECURSIVE q AS (
		SELECT
			1 AS level,
			A.id,
			A.parent_id,
			A.name,
			A.type
		FROM
			modules A
		WHERE
			A.id = moduleid
		UNION ALL
		SELECT
			q.level + 1,
			B.id,
			B.parent_id,
			B.name,
			B.type
		FROM
			q,
			modules B
		WHERE
			B.id = q.parent_id
	)
	SELECT DISTINCT
		q.level,
		q.id,
		q.parent_id,
		q.name,
		q.type
	FROM
		q
	ORDER BY
		q.level,
		q.parent_id;
END;
]]></definition>
</function>

<function name="fn_get_module_descendants"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="level">
		<type name="integer"/>
	</parameter>
	<parameter name="id">
		<type name="uuid"/>
	</parameter>
	<parameter name="parent_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="name">
		<type name="text"/>
	</parameter>
	<parameter name="type">
		<type name="public.module_type" precision="0"/>
	</parameter>
	<parameter name="enabled">
		<type name="boolean"/>
	</parameter>
	</return-type>
	<parameter name="moduleid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
BEGIN
	RETURN QUERY
	WITH RECURSIVE q AS (
		SELECT
			1 AS level,
			A.id,
			A.parent_id,
			A.name,
			A.type,
			fn_is_module_enabled(A.id) AS enabled
		FROM
			modules A
		WHERE
			A.id = moduleid
		UNION ALL
		SELECT
			q.level + 1,
			B.id,
			B.parent_id,
			B.name,
			B.type,
			fn_is_module_enabled(B.id) AS enabled
		FROM
			q,
			modules B
		WHERE
			B.parent_id = q.id
	)
	SELECT DISTINCT
		q.level,
		q.id,
		q.parent_id,
		q.name,
		q.type,
		q.enabled
	FROM
		q
	ORDER BY
		q.level,
		q.parent_id;
END;
]]></definition>
</function>

<function name="fn_is_module_enabled"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="moduleid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	is_disabled	integer;
BEGIN
	SELECT
		COUNT(*)
	FROM
		modules
	WHERE
		id IN  (SELECT id FROM fn_get_module_ancestors(moduleid)) AND
		enabled = false
	INTO
		is_disabled;

	RETURN is_disabled <= 0;
END;
]]></definition>
</function>

<function name="fn_check_module_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	is_module_in_tree	INTEGER;
BEGIN
	IF TG_OP = 'UPDATE'
	THEN
		IF OLD.name <> NEW.name
		THEN
			RAISE SQLSTATE '2F003' USING MESSAGE = 'Module name is NOT mutable';
			RETURN NULL;
		END IF;

		IF OLD.type <> NEW.type
		THEN
			RAISE SQLSTATE '2F003' USING MESSAGE = 'Module type is NOT mutable';
			RETURN NULL;
		END IF;
	END IF;



	IF NEW.parent_id IS NULL
	THEN
		RETURN NEW;
	END IF;

	IF NEW.id = NEW.parent_id
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Module cannot be its own parent';
		RETURN NULL;
	END IF;

	/* Check if the module is its own ancestor */
	is_module_in_tree := 0;
	SELECT
		COUNT(id)
	FROM
		fn_get_module_ancestors(NEW.parent_id)
	WHERE
		id = NEW.id
	INTO
		is_module_in_tree;

	IF is_module_in_tree > 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Module cannot be its own ancestor';
		RETURN NULL;
	END IF;

	/* Check if the module is its own descendant */
	is_module_in_tree := 0;
	SELECT
		COUNT(id)
	FROM
		fn_get_module_descendants(NEW.id)
	WHERE
		id = NEW.id AND
		level > 1
	INTO
		is_module_in_tree;

	IF is_module_in_tree > 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Module cannot be its own descendant';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;
]]></definition>
</function>

<function name="fn_notify_config_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF OLD.configuration = NEW.configuration AND OLD.enabled = NEW.enabled
	THEN
		RETURN NEW;
	END IF;

	IF OLD.configuration <> NEW.configuration
	THEN
		PERFORM pg_notify('config-change', CAST(NEW.id AS text));
	END IF;

	IF OLD.enabled <> NEW.enabled
	THEN
		PERFORM pg_notify('state-change', CAST(NEW.id AS text));
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<table name="modules">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1076.33" y="276.333"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="parent_id">
		<type name="uuid"/>
	</column>
	<column name="type" not-null="true" default-value="'component'">
		<type name="public.module_type"/>
	</column>
	<column name="name" not-null="true">
		<type name="text"/>
	</column>
	<column name="display_name" not-null="true">
		<type name="text"/>
	</column>
	<column name="description" not-null="true" default-value="'Another Twyr Module'">
		<type name="text"/>
	</column>
	<column name="metadata" not-null="true" default-value="'{}'::jsonb">
		<type name="jsonb"/>
	</column>
	<column name="configuration" not-null="true" default-value="'{}'::jsonb">
		<type name="jsonb"/>
	</column>
	<column name="admin_only" default-value="false::boolean">
		<type name="boolean"/>
	</column>
	<column name="enabled" not-null="true" default-value="true::boolean">
		<type name="boolean"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_modules" type="pk-constr" table="public.modules">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<usertype name="tenant_type" configuration="enumeration">
	<schema name="public"/>
	<role name="postgres"/>
	<enumeration values="department,organization"/>
</usertype>

<table name="tenants">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="4225.5" y="312.845"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="parent_id">
		<type name="uuid"/>
	</column>
	<column name="type" not-null="true" default-value="'organization'::tenant_type">
		<type name="public.tenant_type"/>
	</column>
	<column name="name" not-null="true">
		<type name="text"/>
	</column>
	<column name="enabled" not-null="true" default-value="true::boolean">
		<type name="boolean"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_tenants" type="pk-constr" table="public.tenants">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<usertype name="gender" configuration="enumeration">
	<schema name="public"/>
	<role name="postgres"/>
	<enumeration values="female,male,other"/>
</usertype>

<table name="users">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="4974.46" y="1159.12"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="email" not-null="true">
		<type name="text"/>
	</column>
	<column name="password" not-null="true">
		<type name="text"/>
	</column>
	<column name="first_name" not-null="true">
		<type name="text"/>
	</column>
	<column name="middle_names">
		<type name="text"/>
	</column>
	<column name="last_name" not-null="true">
		<type name="text"/>
	</column>
	<column name="nickname">
		<type name="text"/>
	</column>
	<column name="profile_image_id">
		<type name="uuid"/>
	</column>
	<column name="gender" not-null="true" default-value="'male'::gender">
		<type name="public.gender"/>
	</column>
	<column name="dob">
		<type name="date"/>
	</column>
	<column name="home_module_menu_id">
		<type name="uuid"/>
	</column>
	<column name="enabled" not-null="true" default-value="true::boolean">
		<type name="boolean"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_users" type="pk-constr" table="public.users">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_users" table="public.users"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="email"/>
		</idxelement>
</index>

<index name="uidx_tenant_parent_name" table="public.tenants"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="parent_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="name"/>
		</idxelement>
</index>

<table name="tenants_users">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="4230.09" y="1211.26"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="tenant_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="user_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="job_title_id">
		<type name="uuid"/>
	</column>
	<column name="location_id">
		<type name="uuid"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_tenants_users" type="pk-constr" table="public.tenants_users">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_tenants_users" table="public.tenants_users"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="tenant_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="user_id"/>
		</idxelement>
</index>

<table name="locations">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="4026" y="728.93"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="tenant_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="line1" not-null="true">
		<type name="text"/>
	</column>
	<column name="line2">
		<type name="text"/>
	</column>
	<column name="line3">
		<type name="text"/>
	</column>
	<column name="area">
		<type name="text"/>
	</column>
	<column name="city" not-null="true">
		<type name="text"/>
	</column>
	<column name="state" not-null="true">
		<type name="text"/>
	</column>
	<column name="country" not-null="true">
		<type name="text"/>
	</column>
	<column name="postal_code" not-null="true">
		<type name="text"/>
	</column>
	<column name="latitude" not-null="true">
		<type name="double precision"/>
	</column>
	<column name="longitude" not-null="true">
		<type name="double precision"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_locations" type="pk-constr" table="public.locations">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_locations" table="public.locations"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="tenant_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="id"/>
		</idxelement>
</index>

<table name="job_titles">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="4583.28" y="772.58"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="tenant_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="title" not-null="true">
		<type name="text"/>
	</column>
	<column name="description">
		<type name="text"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_job_titles" type="pk-constr" table="public.job_titles">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_job_titles" table="public.job_titles"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="tenant_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="id"/>
		</idxelement>
</index>

<table name="groups">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="3407.33" y="739.93"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="parent_id">
		<type name="uuid"/>
	</column>
	<column name="tenant_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="name" not-null="true">
		<type name="text"/>
	</column>
	<column name="display_name" not-null="true">
		<type name="text"/>
	</column>
	<column name="description">
		<type name="text"/>
	</column>
	<column name="default_for_new_user" not-null="true" default-value="false::boolean">
		<type name="boolean"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="fk_groups" type="pk-constr" table="public.groups">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_group_parent_name" table="public.groups"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="parent_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="name"/>
		</idxelement>
</index>

<index name="uidx_group_tenant" table="public.groups"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="tenant_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="id"/>
		</idxelement>
</index>

<table name="tenant_user_groups">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="3352.02" y="1212.27"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="tenant_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="group_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="user_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_tenant_user_groups" type="pk-constr" table="public.tenant_user_groups">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="permissions">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1087.33" y="740.667"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="module_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="name" not-null="true">
		<type name="text"/>
	</column>
	<column name="display_name" not-null="true">
		<type name="text"/>
	</column>
	<column name="description" not-null="true" default-value="'Another Random Permission'::text">
		<type name="text"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_permissions" type="pk-constr" table="public.permissions">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="fn_get_tenant_ancestors"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="level">
		<type name="integer"/>
	</parameter>
	<parameter name="id">
		<type name="uuid"/>
	</parameter>
	<parameter name="parent_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="name">
		<type name="text"/>
	</parameter>
	<parameter name="type">
		<type name="public.tenant_type" precision="0"/>
	</parameter>
	</return-type>
	<parameter name="tenantid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
BEGIN
	RETURN QUERY
	WITH RECURSIVE q AS (
		SELECT
			1 AS level,
			A.id,
			A.parent_id,
			A.name,
			A.type
		FROM
			tenants A
		WHERE
			A.id = tenantid
		UNION ALL
		SELECT
			q.level + 1,
			B.id,
			B.parent_id,
			B.name,
			B.type
		FROM
			q,
			tenants B
		WHERE
			B.id = q.parent_id
	)
	SELECT DISTINCT
		q.level,
		q.id,
		q.parent_id,
		q.name,
		q.type
	FROM
		q
	ORDER BY
		q.level,
		q.parent_id;
END;
]]></definition>
</function>

<function name="fn_is_tenant_enabled"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="tenantid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	is_disabled	integer;
BEGIN
	SELECT
		COUNT(*)
	FROM
		tenants
	WHERE
		id IN  (SELECT id FROM fn_get_tenant_ancestors(tenantid)) AND
		enabled = false
	INTO
		is_disabled;

	RETURN is_disabled <= 0;
END;
]]></definition>
</function>

<function name="fn_get_tenant_descendants"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="level">
		<type name="integer"/>
	</parameter>
	<parameter name="id">
		<type name="uuid"/>
	</parameter>
	<parameter name="parent_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="name">
		<type name="text"/>
	</parameter>
	<parameter name="type">
		<type name="public.tenant_type" precision="0"/>
	</parameter>
	<parameter name="enabled">
		<type name="boolean"/>
	</parameter>
	</return-type>
	<parameter name="tenantid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
BEGIN
	RETURN QUERY
	WITH RECURSIVE q AS (
		SELECT
			1 AS level,
			A.id,
			A.parent_id,
			A.name,
			A.type,
			fn_is_tenant_enabled(A.id) AS enabled
		FROM
			tenants A
		WHERE
			A.id = tenantid
		UNION ALL
		SELECT
			q.level + 1,
			B.id,
			B.parent_id,
			B.name,
			B.type,
			fn_is_tenant_enabled(B.id) AS enabled
		FROM
			q,
			tenants B
		WHERE
			B.parent_id = q.id
	)
	SELECT DISTINCT
		q.level,
		q.id,
		q.parent_id,
		q.name,
		q.type,
		q.enabled
	FROM
		q
	ORDER BY
		q.level,
		q.parent_id;
END;
]]></definition>
</function>

<function name="fn_check_tenant_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	is_tenant_in_tree	INTEGER;
BEGIN
	IF NEW.parent_id IS NULL
	THEN
		RETURN NEW;
	END IF;

	IF NEW.id = NEW.parent_id
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Tenant cannot be its own parent';
		RETURN NULL;
	END IF;

	/* Check if the tenant is its own ancestor */
	is_tenant_in_tree := 0;
	SELECT
		COUNT(id)
	FROM
		fn_get_tenant_ancestors(NEW.parent_id)
	WHERE
		id = NEW.id
	INTO
		is_tenant_in_tree;

	IF is_tenant_in_tree > 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Tenant cannot be its own ancestor';
		RETURN NULL;
	END IF;

	/* Check if the tenant is its own descendant */
	is_tenant_in_tree := 0;
	SELECT
		COUNT(id)
	FROM
		fn_get_tenant_descendants(NEW.id)
	WHERE
		id = NEW.id AND
		level > 1
	INTO
		is_tenant_in_tree;

	IF is_tenant_in_tree > 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Tenant cannot be its own descendant';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;
]]></definition>
</function>

<trigger name="trigger_check_tenant_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.tenants">
		<function signature="public.fn_check_tenant_upsert_is_valid()"/>
</trigger>

<function name="fn_get_group_ancestors"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="level">
		<type name="integer"/>
	</parameter>
	<parameter name="id">
		<type name="uuid"/>
	</parameter>
	<parameter name="parent_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="name">
		<type name="text"/>
	</parameter>
	</return-type>
	<parameter name="groupid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
BEGIN
	RETURN QUERY
	WITH RECURSIVE q AS (
		SELECT
			1 AS level,
			A.id,
			A.parent_id,
			A.name
		FROM
			groups A
		WHERE
			A.id = groupid
		UNION ALL
		SELECT
			q.level + 1,
			B.id,
			B.parent_id,
			B.name
		FROM
			q,
			groups B
		WHERE
			B.id = q.parent_id
	)
	SELECT DISTINCT
		q.level,
		q.id,
		q.parent_id,
		q.name
	FROM
		q
	ORDER BY
		q.level,
		q.parent_id;
END;
]]></definition>
</function>

<function name="fn_get_group_descendants"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="level">
		<type name="integer"/>
	</parameter>
	<parameter name="id">
		<type name="uuid"/>
	</parameter>
	<parameter name="parent_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="name">
		<type name="text"/>
	</parameter>
	</return-type>
	<parameter name="groupid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
BEGIN
	RETURN QUERY
	WITH RECURSIVE q AS (
		SELECT
			1 AS level,
			A.id,
			A.parent_id,
			A.name
		FROM
			groups A
		WHERE
			A.id = groupid
		UNION ALL
		SELECT
			q.level + 1,
			B.id,
			B.parent_id,
			B.name
		FROM
			q,
			groups B
		WHERE
			B.parent_id = q.id
	)
	SELECT DISTINCT
		q.level,
		q.id,
		q.parent_id,
		q.name
	FROM
		q
	ORDER BY
		q.level,
		q.parent_id;
END;
]]></definition>
</function>

<function name="fn_check_group_update_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[BEGIN
	IF OLD.parent_id <> NEW.parent_id
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Group cannot change parent';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_check_group_update_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="public.groups">
		<function signature="public.fn_check_group_update_is_valid()"/>
</trigger>

<function name="fn_assign_default_group_to_tenant_user"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	default_group_id	UUID;
BEGIN
	default_group_id := NULL;
	SELECT
		id
	FROM
		groups
	WHERE
		tenant_id = NEW.tenant_id AND
		default_for_new_user = true
	INTO
		default_group_id;

	IF default_group_id IS NULL
	THEN
		RETURN NEW;
	END IF;

	INSERT INTO tenant_user_groups (
		tenant_id,
		group_id,
		user_id
	)
	VALUES (
		NEW.tenant_id,
		default_group_id,
		NEW.user_id
	);

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_assign_default_group_to_tenant_user" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="public.tenants_users">
		<function signature="public.fn_assign_default_group_to_tenant_user()"/>
</trigger>

<function name="fn_remove_group_permission_from_descendants"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	DELETE FROM
		group_permissions
	WHERE
		group_id IN (SELECT id FROM fn_get_group_descendants(OLD.group_id) WHERE level = 2) AND
		permission_id = OLD.permission_id;

	RETURN OLD;
END;]]></definition>
</function>

<table name="social_logins">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="5037.86" y="768.976"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="user_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="provider" not-null="true">
		<type name="text"/>
	</column>
	<column name="provider_id" not-null="true">
		<type name="text"/>
	</column>
	<column name="display_name" not-null="true">
		<type name="text"/>
	</column>
	<column name="social_data" not-null="true">
		<type name="jsonb"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_social_logins" type="pk-constr" table="public.social_logins">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_social_logins" table="public.social_logins"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="provider"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="provider_id"/>
		</idxelement>
</index>

<table name="group_permissions">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="2388.46" y="756.25"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="tenant_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="group_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="module_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="permission_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_group_permissions" type="pk-constr" table="public.group_permissions">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="fn_assign_defaults_to_tenant"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	INSERT INTO groups (
		parent_id,
		tenant_id,
		name,
		display_name,
		description
	)
	VALUES (
		NULL,
		NEW.id,
		'administrators'
		NEW.name || 'Administrators',
		'The Administrator Group for ' || NEW.name
	);

	IF NEW.parent_id IS NOT NULL
	THEN
		INSERT INTO tenant_modules (
			tenant_id,
			module_id
		)
		SELECT 
			NEW.id,
			id
		FROM
			modules
		WHERE
			admin_only = false AND
			type = 'component';
	END IF;

	IF NEW.parent_id IS NULL
	THEN
		INSERT INTO tenant_modules (
			tenant_id,
			module_id
		)
		SELECT 
			NEW.id,
			id
		FROM
			modules
		WHERE
			type = 'component';
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_assign_defaults_to_tenant" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="public.tenants">
		<function signature="public.fn_assign_defaults_to_tenant()"/>
</trigger>

<function name="fn_check_permission_insert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	is_component	INTEGER;
BEGIN
	SELECT
		count(id)
	FROM
		modules
	WHERE
		id = NEW.module_id AND
		type = 'component'
	INTO
		is_component;

	IF is_component <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Permissions can be defined only for components, and not for other types of modules';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_check_permission_insert_is_valid" firing-type="BEFORE" per-line="false" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="public.permissions">
		<function signature="public.fn_check_permission_insert_is_valid()"/>
</trigger>

<function name="fn_check_permission_update_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	IF OLD.module_id <> NEW.module_id
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Module assigned to a permission is NOT mutable';
		RETURN NULL;
	END IF;

	IF OLD.name <> NEW.name
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Permission name is NOT mutable';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_check_permission_update_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="public.permissions">
		<function signature="public.fn_check_permission_update_is_valid()"/>
</trigger>

<table name="tenant_modules">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="2409.95" y="339.25"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="tenant_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="module_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_tenant_modules" type="pk-constr" table="public.tenant_modules">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="fn_check_tenant_module_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	is_component	INTEGER;
	is_admin_only	BOOLEAN;
	component_parent_id	UUID;
	tenant_parent_id	UUID;
BEGIN
	is_component := 0;
	SELECT
		count(id)
	FROM
		modules
	WHERE
		id = NEW.module_id AND
		type = 'component'
	INTO
		is_component;

	IF is_component <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Only components can be mapped to tenants';
		RETURN NULL;
	END IF;

	component_parent_id := NULL;
	SELECT 
		parent_id
	FROM
		modules
	WHERE
		id = NEW.module_id
	INTO
		component_parent_id;

	IF component_parent_id IS NOT NULL
	THEN
		is_component := 0;
		SELECT
			count(id)
		FROM
			tenant_modules
		WHERE
			tenant_id = NEW.tenant_id AND
			module_id = component_parent_id
		INTO
			is_component;

		IF is_component = 0
		THEN
			RAISE SQLSTATE '2F003' USING MESSAGE = 'Parent component not mapped to this Tenant';
			RETURN NULL;
		END IF;
	END IF;

	is_admin_only := false;
	SELECT
		admin_only
	FROM
		modules
	WHERE
		id = NEW.module_id
	INTO
		is_admin_only;

	IF is_admin_only = false
	THEN
		RETURN NEW;
	END IF;

	tenant_parent_id := NULL;
	SELECT
		parent_id
	FROM
		tenants
	WHERE
		id = NEW.tenant_id
	INTO
		tenant_parent_id;

	IF tenant_parent_id IS NOT NULL
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Admin only components can be mapped only to root tenant';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_check_tenant_module_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.tenant_modules">
		<function signature="public.fn_check_tenant_module_upsert_is_valid()"/>
</trigger>

<trigger name="trigger_notify_config_change" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="public.modules">
		<function signature="public.fn_notify_config_change()"/>
</trigger>

<trigger name="trigger_check_module_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.modules">
		<function signature="public.fn_check_module_upsert_is_valid()"/>
</trigger>

<trigger name="trigger_assign_module_to_tenant" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="public.modules">
		<function signature="public.fn_assign_module_to_tenant()"/>
</trigger>

<index name="uidx_module_parent_name" table="public.modules"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="parent_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="name"/>
		</idxelement>
</index>

<index name="uidx_permissions" table="public.permissions"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="module_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="name"/>
		</idxelement>
</index>

<trigger name="trigger_remove_group_permission_from_descendants" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="public.group_permissions">
		<function signature="public.fn_remove_group_permission_from_descendants()"/>
</trigger>

<index name="uidx_tenant_modules" table="public.tenant_modules"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="tenant_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="module_id"/>
		</idxelement>
</index>

<index name="uidx_permissions_modules" table="public.permissions"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="module_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="id"/>
		</idxelement>
</index>

<function name="fn_assign_permission_to_tenant_group"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	tenant_root_group_id	UUID;
BEGIN
	tenant_root_group_id := NULL;
	SELECT
		id
	FROM
		groups
	WHERE
		tenant_id = NEW.tenant_id AND
		parent_id IS NULL
	INTO
		tenant_root_group_id;

	IF tenant_root_group_id IS NULL
	THEN
		RETURN NEW;
	END IF;

	INSERT INTO group_permissions(
		tenant_id,
		group_id,
		module_id,
		permission_id
	)
	SELECT
		NEW.tenant_id,
		tenant_root_group_id,
		module_id,
		id
	FROM
		permissions
	WHERE
		module_id = NEW.module_id;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_assign_permission_to_tenant_group" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.tenant_modules">
		<function signature="public.fn_assign_permission_to_tenant_group()"/>
</trigger>

<index name="uidx_group_permissions" table="public.group_permissions"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="group_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="permission_id"/>
		</idxelement>
</index>

<function name="fn_assign_permission_to_tenants"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[BEGIN
	INSERT INTO group_permissions (
		tenant_id,
		group_id,
		module_id,
		permission_id
	)
	SELECT
		A.tenant_id,
		B.id,
		A.module_id,
		NEW.id
	FROM
		tenant_modules A
		INNER JOIN groups B ON (A.tenant_id = B.tenant_id AND B.parent_id IS NULL)
	WHERE
		module_id = NEW.module_id;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_assign_permission_to_tenants" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="public.permissions">
		<function signature="public.fn_assign_permission_to_tenants()"/>
</trigger>

<index name="uidx_tenant_user_groups" table="public.tenant_user_groups"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="tenant_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="group_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="user_id"/>
		</idxelement>
</index>

<function name="fn_remove_descendant_group_from_tenant_user"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[BEGIN
	DELETE FROM 
		tenant_user_groups
	WHERE
		tenant_id = NEW.tenant_id AND
		group_id IN (SELECT id FROM fn_get_group_descendants(NEW.group_id) WHERE level > 1) AND
		user_id = NEW.user_id;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_remove_descendant_group_from_tenant_user" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.tenant_user_groups">
		<function signature="public.fn_remove_descendant_group_from_tenant_user()"/>
</trigger>

<function name="fn_check_group_permission_insert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[DECLARE
	parent_group_id			UUID;
	does_parent_group_have_permission	INTEGER;
BEGIN
	parent_group_id := NULL;
	SELECT
		parent_id
	FROM
		groups
	WHERE
		id = NEW.group_id
	INTO
		parent_group_id;

	IF parent_group_id IS NULL
	THEN
		RETURN NEW;
	END IF;

	does_parent_group_have_permission := 0;
	SELECT
		count(id)
	FROM
		group_permissions
	WHERE
		group_id = parent_group_id AND
		permission_id = NEW.permission_id
	INTO
		does_parent_group_have_permission;

	IF does_parent_group_have_permission > 0
	THEN
		RETURN NEW;
	END IF;

	RAISE SQLSTATE '2F003' USING MESSAGE = 'Parent Group does not have this permission';	
	RETURN NULL;
END;]]></definition>
</function>

<trigger name="trigger_check_group_permission_insert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.group_permissions">
		<function signature="public.fn_check_group_permission_insert_is_valid()"/>
</trigger>

<function name="fn_check_tenant_user_group_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[DECLARE
	is_member_of_ancestor_group	INTEGER;
BEGIN
	is_member_of_ancestor_group := 0;
	SELECT
		count(id)
	FROM
		tenant_user_groups
	WHERE
		tenant_id = NEW.tenant_id AND
		group_id IN (SELECT id FROM fn_get_group_ancestors(NEW.group_id) WHERE level > 1) AND
		user_id = NEW.user_id
	INTO
		is_member_of_ancestor_group;

	IF is_member_of_ancestor_group = 0
	THEN
		RETURN NEW;
	END IF;

	RAISE SQLSTATE '2F003' USING MESSAGE = 'User is already a member of a Parent Group';
	RETURN NULL;
END;]]></definition>
</function>

<trigger name="trigger_check_tenant_user_group_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.tenant_user_groups">
		<function signature="public.fn_check_tenant_user_group_upsert_is_valid()"/>
</trigger>

<table name="module_menus">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1377.43" y="1176.09"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="parent_id">
		<type name="uuid"/>
	</column>
	<column name="module_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="permission_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="ember_route" not-null="true">
		<type name="text"/>
	</column>
	<column name="icon_class">
		<type name="text"/>
	</column>
	<column name="display_name" not-null="true">
		<type name="text"/>
	</column>
	<column name="description">
		<type name="text"/>
	</column>
	<column name="tooltip">
		<type name="text"/>
	</column>
	<column name="is_default_home" not-null="true" default-value="false::boolean">
		<type name="boolean"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_module_menus" type="pk-constr" table="public.module_menus">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_module_menus_module_route" table="public.module_menus"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="ember_route"/>
		</idxelement>
</index>

<index name="uidx_module_menus_module_name" table="public.module_menus"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="module_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="display_name"/>
		</idxelement>
</index>

<function name="fn_check_module_menu_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[DECLARE
	is_component		INTEGER;
	is_permission_ok		INTEGER;
	is_module_menu_in_tree	INTEGER;
BEGIN
	is_component := 0;
	SELECT
		count(id)
	FROM
		modules
	WHERE
		id = NEW.module_id AND
		type = 'component'
	INTO
		is_component;

	IF is_component <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Menus can be assigned only to Components';
		RETURN NULL;
	END IF;

	is_permission_ok := 0;
	SELECT
		count(id)
	FROM
		permissions
	WHERE
		module_id IN (SELECT id FROM fn_get_module_ancestors(NEW.module_id)) AND
		id = NEW.permission_id
	INTO
		is_permission_ok;

	IF is_permission_ok <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Menus must use Permissions defined by the Component or one of its parents';
		RETURN NULL;
	END IF;

	IF NEW.parent_id IS NULL
	THEN
		RETURN NEW;
	END IF;

	IF NEW.id = NEW.parent_id
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Menu cannot be its own parent';
		RETURN NULL;
	END IF;

	/* Check if the module is its own ancestor */
	is_module_in_tree := 0;
	SELECT
		COUNT(id)
	FROM
		fn_get_module_menu_ancestors(NEW.parent_id)
	WHERE
		id = NEW.id
	INTO
		is_module_menu_in_tree;

	IF is_module_menu_in_tree > 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Menu cannot be its own ancestor';
		RETURN NULL;
	END IF;

	/* Check if the module is its own descendant */
	is_module_menu_in_tree := 0;
	SELECT
		COUNT(id)
	FROM
		fn_get_module_menu_descendants(NEW.id)
	WHERE
		id = NEW.id AND
		level > 1
	INTO
		is_module_menu_in_tree;

	IF is_module_menu_in_tree > 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Menu cannot be its own descendant';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_check_module_menu_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.module_menus">
		<function signature="public.fn_check_module_menu_upsert_is_valid()"/>
</trigger>

<table name="module_widgets">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="853.667" y="1179.33"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="module_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="permission_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="ember_component" not-null="true">
		<type name="text"/>
	</column>
	<column name="display_name" not-null="true">
		<type name="text"/>
	</column>
	<column name="description">
		<type name="text"/>
	</column>
	<column name="metadata" not-null="true" default-value="'{}'::jsonb">
		<type name="jsonb"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_module_widgets" type="pk-constr" table="public.module_widgets">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_module_widgets" table="public.module_widgets"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="ember_component"/>
		</idxelement>
</index>

<function name="fn_check_module_widget_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[DECLARE
	is_component	INTEGER;
	is_permission_ok	INTEGER;
BEGIN
	is_component := 0;
	SELECT
		count(id)
	FROM
		modules
	WHERE
		id = NEW.module_id AND
		type = 'component'
	INTO
		is_component;

	IF is_component <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Widgets can be assigned only to Components';
		RETURN NULL;
	END IF;

	is_permission_ok := 0;
	SELECT
		count(id)
	FROM
		permissions
	WHERE
		module_id IN (SELECT id FROM fn_get_module_ancestors(NEW.module_id)) AND
		id = NEW.permission_id
	INTO
		is_permission_ok;

	IF is_permission_ok <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Widgets must use Permissions defined by the Component or one of its parents';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<function name="fn_get_module_menu_ancestors"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="level">
		<type name="integer"/>
	</parameter>
	<parameter name="id">
		<type name="uuid"/>
	</parameter>
	<parameter name="parent_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="ember_route">
		<type name="text"/>
	</parameter>
	</return-type>
	<parameter name="menuid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[
BEGIN
	RETURN QUERY
	WITH RECURSIVE q AS (
		SELECT
			1 AS level,
			A.id,
			A.parent_id,
			A.ember_route
		FROM
			module_menus A
		WHERE
			A.id = menuid
		UNION ALL
		SELECT
			q.level + 1,
			B.id,
			B.parent_id,
			B.ember_route
		FROM
			q,
			module_menus B
		WHERE
			B.id = q.parent_id
	)
	SELECT DISTINCT
		q.level,
		q.id,
		q.parent_id,
		q.ember_route
	FROM
		q
	ORDER BY
		q.level,
		q.parent_id;
END;
]]></definition>
</function>

<function name="fn_get_module_menu_descendants"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="level">
		<type name="integer"/>
	</parameter>
	<parameter name="id">
		<type name="uuid"/>
	</parameter>
	<parameter name="parent_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="ember_route">
		<type name="text"/>
	</parameter>
	</return-type>
	<definition><![CDATA[
BEGIN
	RETURN QUERY
	WITH RECURSIVE q AS (
		SELECT
			1 AS level,
			A.id,
			A.parent_id,
			A.ember_route
		FROM
			module_menus A
		WHERE
			A.id = menuid
		UNION ALL
		SELECT
			q.level + 1,
			B.id,
			B.parent_id,
			B.ember_route
		FROM
			q,
			module_menus B
		WHERE
			B.parent_id = q.id
	)
	SELECT DISTINCT
		q.level,
		q.id,
		q.parent_id,
		q.ember_route
	FROM
		q
	ORDER BY
		q.level,
		q.parent_id;
END;
]]></definition>
</function>

<usertype name="template_media_type" configuration="enumeration">
	<schema name="public"/>
	<role name="postgres"/>
	<enumeration values="all,desktop,tablet,mobile,other"/>
</usertype>

<usertype name="template_user_type" configuration="enumeration">
	<schema name="public"/>
	<role name="postgres"/>
	<enumeration values="all,public,registered,administrator,other"/>
</usertype>

<table name="module_templates">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="90.5597" y="298.66"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="module_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="name" not-null="true">
		<type name="text"/>
	</column>
	<column name="description">
		<type name="text"/>
	</column>
	<column name="media_type" not-null="true" default-value="'all'::template_media_type">
		<type name="public.template_media_type"/>
	</column>
	<column name="user_type" not-null="true" default-value="'all'::template_user_type">
		<type name="public.template_user_type"/>
	</column>
	<column name="is_default" not-null="true" default-value="false::boolean">
		<type name="boolean"/>
	</column>
	<column name="configuration" not-null="true" default-value="'{}'::jsonb">
		<type name="jsonb"/>
	</column>
	<column name="metadata" not-null="true" default-value="'{}'::jsonb">
		<type name="jsonb"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_module_templates" type="pk-constr" table="public.module_templates">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="uidx_module_templates" table="public.module_templates"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="module_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="name"/>
		</idxelement>
</index>

<function name="fn_get_user_permissions"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<parameter name="tenant_id">
		<type name="uuid"/>
	</parameter>
	<parameter name="permission_id">
		<type name="uuid"/>
	</parameter>
	</return-type>
	<parameter name="userid" in="true">
		<type name="uuid"/>
	</parameter>
	<definition><![CDATA[BEGIN
	RETURN QUERY
	SELECT DISTINCT
		A.tenant_id,
		A.permission_id
	FROM
		group_permissions A
	WHERE
		A.group_id IN (SELECT group_id FROM tenant_user_groups WHERE user_id = userid);
END;]]></definition>
</function>

<function name="fn_check_user_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[DECLARE
	is_valid_home_module_menu INTEGER;
BEGIN
	IF NEW.home_module_menu_id IS NULL
	THEN
		RETURN NEW;
	END IF;

	is_valid_home_module_menu := 0;
	SELECT
		count(id)
	FROM
		module_menus
	WHERE
		id = NEW.home_module_menu_id AND
		permission_id IN (SELECT DISTINCT permission_id FROM fn_get_user_permissions(NEW.id))
	INTO
		is_valid_home_module_menu;

	IF is_valid_home_module_menu <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'User does not have permissions for chosen Home Menu';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<table name="template_positions">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="248.214" y="737.857"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="template_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="name" not-null="true">
		<type name="text"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_template_positions" type="pk-constr" table="public.template_positions">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="widget_template_position">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="122.436" y="1199.82"/>
	<column name="id" not-null="true" default-value="uuid_generate_v4()">
		<type name="uuid"/>
	</column>
	<column name="template_position_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="module_widget_id" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="display_order" not-null="true" default-value="1">
		<type name="integer"/>
	</column>
	<column name="created_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<column name="updated_at" not-null="true" default-value="now()">
		<type name="timestamptz"/>
	</column>
	<constraint name="pk_widget_template_position" type="pk-constr" table="public.widget_template_position">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<function name="fn_check_widget_template_position_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[DECLARE
	template_module_id 	UUID;
	widget_module_id	UUID;
	is_child_component	INTEGER;
BEGIN
	template_module_id := NULL;
	widget_module_id := NULL;
	is_child_component := 0;

	SELECT
		module_id
	FROM
		module_templates
	WHERE
		id = (SELECT template_id FROM template_positions WHERE id = NEW.template_position_id)
	INTO
		template_module_id;

	SELECT
		module_id
	FROM
		module_widgets
	WHERE
		id = NEW.module_widget_id
	INTO
		widget_module_id;

	SELECT
		count(A.id)
	FROM
		(SELECT id FROM fn_get_module_descendants(template_module_id) WHERE level <= 2) A
	WHERE
		A.id = widget_module_id
	INTO
		is_child_component;

	IF is_child_component <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Only widgets belonging to the same component or one of its children can be assigned to a components template';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<index name="uidx_widget_template_position" table="public.widget_template_position"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="template_position_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="module_widget_id"/>
		</idxelement>
</index>

<trigger name="trigger_check_widget_template_position_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.widget_template_position">
		<function signature="public.fn_check_widget_template_position_upsert_is_valid()"/>
</trigger>

<trigger name="trigger_check_module_widget_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.module_widgets">
		<function signature="public.fn_check_module_widget_upsert_is_valid()"/>
</trigger>

<trigger name="trigger_check_user_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.users">
		<function signature="public.fn_check_user_upsert_is_valid()"/>
</trigger>

<function name="fn_check_module_template_upsert_is_valid"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[DECLARE
	is_component	INTEGER;
BEGIN
	is_component := 0;
	SELECT
		count(id)
	FROM
		modules
	WHERE
		id = NEW.module_id AND
		type = 'component'
	INTO
		is_component;

	IF is_component <= 0
	THEN
		RAISE SQLSTATE '2F003' USING MESSAGE = 'Templates can be assigned only to Components';
		RETURN NULL;
	END IF;

	RETURN NEW;
END;]]></definition>
</function>

<trigger name="trigger_check_module_template_upsert_is_valid" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="public.module_templates">
		<function signature="public.fn_check_module_template_upsert_is_valid()"/>
</trigger>

<constraint name="fk_modules_modules" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="public.modules" table="public.modules">
	<columns names="parent_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenant_parent" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.tenants" table="public.tenants">
	<columns names="parent_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenants_users_users" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.users" table="public.tenants_users">
	<columns names="user_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenants_users_tenants" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.tenants" table="public.tenants_users">
	<columns names="tenant_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenants_users_locations" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.locations" table="public.tenants_users">
	<columns names="tenant_id,location_id" ref-type="src-columns"/>
	<columns names="tenant_id,id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenants_users_job_titles" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.job_titles" table="public.tenants_users">
	<columns names="tenant_id,job_title_id" ref-type="src-columns"/>
	<columns names="id,tenant_id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_locations_tenants" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.tenants" table="public.locations">
	<columns names="tenant_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_job_titles_tenants" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.tenants" table="public.job_titles">
	<columns names="tenant_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_group_tenant" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.tenants" table="public.groups">
	<columns names="tenant_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_groups_groups" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.groups" table="public.groups">
	<columns names="parent_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenant_user_groups_groups" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.groups" table="public.tenant_user_groups">
	<columns names="tenant_id,group_id" ref-type="src-columns"/>
	<columns names="tenant_id,id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenant_user_groups_tenant_users" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.tenants_users" table="public.tenant_user_groups">
	<columns names="tenant_id,user_id" ref-type="src-columns"/>
	<columns names="tenant_id,user_id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_permissions_modules" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.modules" table="public.permissions">
	<columns names="module_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_social_logins_users" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.users" table="public.social_logins">
	<columns names="user_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_group_permissions_groups" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.groups" table="public.group_permissions">
	<columns names="tenant_id,group_id" ref-type="src-columns"/>
	<columns names="tenant_id,id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_group_permissions_permissions" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.permissions" table="public.group_permissions">
	<columns names="module_id,permission_id" ref-type="src-columns"/>
	<columns names="module_id,id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_group_permissions_tenant_modules" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.tenant_modules" table="public.group_permissions">
	<columns names="tenant_id,module_id" ref-type="src-columns"/>
	<columns names="tenant_id,module_id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenant_modules_tenants" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.tenants" table="public.tenant_modules">
	<columns names="tenant_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_tenant_modules_modules" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.modules" table="public.tenant_modules">
	<columns names="module_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_module_menus_module_menus" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.module_menus" table="public.module_menus">
	<columns names="parent_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_module_menus_modules" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.modules" table="public.module_menus">
	<columns names="module_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_module_menus_permissions" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.permissions" table="public.module_menus">
	<columns names="permission_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_module_widgets_modules" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.modules" table="public.module_widgets">
	<columns names="module_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_module_widgets_permissions" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.permissions" table="public.module_widgets">
	<columns names="permission_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_module_templates_modules" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.modules" table="public.module_templates">
	<columns names="module_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_template_positions_templates" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.module_templates" table="public.template_positions">
	<columns names="template_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_widget_template_position_module_widget" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.module_widgets" table="public.widget_template_position">
	<columns names="module_widget_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_widget_template_position_template_positions" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.template_positions" table="public.widget_template_position">
	<columns names="template_position_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_modules_modules" type="relfk"
	 src-table="public.modules"
	 dst-table="public.modules"
	 src-required="false" dst-required="false">
	<line>
		<position x="1521.16" y="383.613"/>
	<position x="1521.16" y="266.333"/>
	<position x="1366.22" y="266.333"/>
	</line>
</relationship>

<relationship name="rel_permissions_modules" type="relfk"
	 src-table="public.permissions"
	 dst-table="public.modules"
	 src-required="false" dst-required="false"/>

<relationship name="rel_tenants_tenants" type="relfk"
	 src-table="public.tenants"
	 dst-table="public.tenants"
	 src-required="false" dst-required="false">
	<line>
		<position x="4659.39" y="384.125"/>
	<position x="4659.39" y="302.845"/>
	<position x="4508.09" y="302.845"/>
	</line>
</relationship>

<relationship name="rel_tenants_users_users" type="relfk"
	 src-table="public.tenants_users"
	 dst-table="public.users"
	 src-required="false" dst-required="false">
	<label ref-type="dst-label">
		<position x="-20.0695" y="-16.3167"/>
	</label>
</relationship>

<relationship name="rel_locations_tenants" type="relfk"
	 src-table="public.locations"
	 dst-table="public.tenants"
	 src-required="false" dst-required="false"/>

<relationship name="rel_job_titles_tenants" type="relfk"
	 src-table="public.job_titles"
	 dst-table="public.tenants"
	 src-required="false" dst-required="false"/>

<relationship name="rel_tenants_users_locations" type="relfk"
	 src-table="public.tenants_users"
	 dst-table="public.locations"
	 src-required="false" dst-required="false"/>

<relationship name="rel_tenants_users_job_titles" type="relfk"
	 src-table="public.tenants_users"
	 dst-table="public.job_titles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_tenants_users_tenants" type="relfk"
	 src-table="public.tenants_users"
	 dst-table="public.tenants"
	 src-required="false" dst-required="false"/>

<relationship name="rel_groups_tenants" type="relfk"
	 src-table="public.groups"
	 dst-table="public.tenants"
	 src-required="false" dst-required="false"/>

<relationship name="rel_groups_groups" type="relfk"
	 src-table="public.groups"
	 dst-table="public.groups"
	 src-required="false" dst-required="false">
	<line>
		<position x="3797.1" y="823.21"/>
	<position x="3797.1" y="729.93"/>
	<position x="3660.51" y="729.93"/>
	</line>
</relationship>

<relationship name="rel_tenant_user_groups_groups" type="relfk"
	 src-table="public.tenant_user_groups"
	 dst-table="public.groups"
	 src-required="false" dst-required="false"/>

<relationship name="rel_tenant_user_groups_tenants_users" type="relfk"
	 src-table="public.tenant_user_groups"
	 dst-table="public.tenants_users"
	 src-required="false" dst-required="false"/>

<relationship name="rel_group_permissions_groups" type="relfk"
	 src-table="public.group_permissions"
	 dst-table="public.groups"
	 src-required="false" dst-required="false"/>

<relationship name="rel_group_permissions_permissions" type="relfk"
	 src-table="public.group_permissions"
	 dst-table="public.permissions"
	 src-required="false" dst-required="false"/>

<relationship name="rel_social_logins_users" type="relfk"
	 src-table="public.social_logins"
	 dst-table="public.users"
	 src-required="false" dst-required="false"/>

<relationship name="rel_tenant_modules_tenants" type="relfk"
	 src-table="public.tenant_modules"
	 dst-table="public.tenants"
	 src-required="false" dst-required="false"/>

<relationship name="rel_tenant_modules_modules" type="relfk"
	 src-table="public.tenant_modules"
	 dst-table="public.modules"
	 src-required="false" dst-required="false"/>

<relationship name="rel_group_permissions_tenant_modules" type="relfk"
	 src-table="public.group_permissions"
	 dst-table="public.tenant_modules"
	 src-required="false" dst-required="false"/>

<relationship name="rel_module_menus_module_menus" type="relfk"
	 src-table="public.module_menus"
	 dst-table="public.module_menus"
	 src-required="false" dst-required="false">
	<line>
		<position x="1816.85" y="1277.37"/>
	<position x="1816.85" y="1166.09"/>
	<position x="1663.71" y="1166.09"/>
	</line>
</relationship>

<relationship name="rel_module_menus_modules" type="relfk"
	 src-table="public.module_menus"
	 dst-table="public.modules"
	 src-required="false" dst-required="false"/>

<relationship name="rel_module_menus_permissions" type="relfk"
	 src-table="public.module_menus"
	 dst-table="public.permissions"
	 src-required="false" dst-required="false"/>

<relationship name="rel_module_widgets_modules" type="relfk"
	 src-table="public.module_widgets"
	 dst-table="public.modules"
	 src-required="false" dst-required="false"/>

<relationship name="rel_module_widgets_permissions" type="relfk"
	 src-table="public.module_widgets"
	 dst-table="public.permissions"
	 src-required="false" dst-required="false"/>

<relationship name="rel_module_templates_modules" type="relfk"
	 src-table="public.module_templates"
	 dst-table="public.modules"
	 src-required="false" dst-required="false"/>

<relationship name="rel_template_positions_module_templates" type="relfk"
	 src-table="public.template_positions"
	 dst-table="public.module_templates"
	 src-required="false" dst-required="false"/>

<relationship name="rel_widget_template_position_module_widgets" type="relfk"
	 src-table="public.widget_template_position"
	 dst-table="public.module_widgets"
	 src-required="false" dst-required="false"/>

<relationship name="rel_widget_template_position_template_positions" type="relfk"
	 src-table="public.widget_template_position"
	 dst-table="public.template_positions"
	 src-required="false" dst-required="false"/>

</dbmodel>
